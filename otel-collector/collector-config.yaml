receivers:
  # OTLP receiver for APM traces from applications
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318
        cors:
          allowed_origins:
            - "http://localhost:8080"
            - "http://localhost:8081"
            - "http://localhost:8000"
          allowed_headers:
            - "*"

  # Host metrics for testing Observe connectivity
  hostmetrics:
    collection_interval: 30s
    scrapers:
      cpu:
      memory:
  
  sqlquery:
    driver: oracle
    datasource: "oracle://otel_monitor:${ORACLE_PASSWORD}@oracle-db:1521/XEPDB1"
    collection_interval: 30s
    queries:
      # 1) Recent SQL Queries (captures API calls) 
      - sql: |
          SELECT
            NVL(sql.sql_id, 'unknown') AS SQL_ID,
            NVL(sql.plan_hash_value, 0) AS PLAN_HASH_VALUE,
            NVL(sql.parsing_schema_name, 'unknown') AS SCHEMA_NAME,
            'recent_sql' AS LOG_TYPE,
            TRUNC(sql.elapsed_time / 1000000) AS EXECUTION_TIME_SECONDS,
            sql.executions AS EXECUTION_COUNT,
            TRUNC(sql.last_active_time) AS LAST_ACTIVE_TIME,
            SUBSTR(sql.sql_text, 1, 100) AS SQL_TEXT_PREVIEW,
            NVL(REGEXP_SUBSTR(sql.sql_text, 'CORRELATION_ID=([a-zA-Z0-9\-_]+)', 1, 1, NULL, 1), 'none') AS CORRELATION_ID,
            NVL(REGEXP_SUBSTR(sql.sql_text, 'USER_ACTION=([a-zA-Z0-9\-_]+)', 1, 1, NULL, 1), 'none') AS USER_ACTION
          FROM v$sql sql
          WHERE sql.last_active_time > SYSDATE - INTERVAL '2' MINUTE
            AND sql.parsing_schema_name IN ('TESTUSER', 'SYS')
            AND sql.sql_text NOT LIKE '%v$sql%'
            AND sql.executions > 0
        metrics:
          - metric_name: oracle.sql.execution_time
            value_column: EXECUTION_TIME_SECONDS
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, PLAN_HASH_VALUE, SCHEMA_NAME, EXECUTION_COUNT]
        logs:
          - body_column: SQL_TEXT_PREVIEW
            attribute_columns: [SQL_ID, SCHEMA_NAME, LOG_TYPE, EXECUTION_COUNT, EXECUTION_TIME_SECONDS, PLAN_HASH_VALUE, CORRELATION_ID, USER_ACTION]

      # 2) SQL Execution Monitoring
      - sql: |
          SELECT
            sql_id AS SQL_ID,
            sql_exec_id AS EXEC_ID,
            sql_plan_hash_value AS PLAN_HASH_VALUE,
            status AS STATUS,
            username AS USERNAME,
            module AS MODULE,
            CAST(TRUNC(elapsed_time/1000000) AS NUMBER(10,0)) AS ELAPSED_TIME_SECONDS,
            CAST(TRUNC(cpu_time/1000000) AS NUMBER(10,0)) AS CPU_TIME_SECONDS,
            buffer_gets AS BUFFER_GETS,
            disk_reads AS DISK_READS,
            direct_writes AS DIRECT_WRITES,
            CAST(TRUNC(physical_read_bytes/1024/1024) AS NUMBER(10,0)) AS PHYSICAL_READ_MB,
            CAST(TRUNC(physical_write_bytes/1024/1024) AS NUMBER(10,0)) AS PHYSICAL_WRITE_MB
          FROM v$sql_monitor
          WHERE status = 'EXECUTING'
        metrics:
          - metric_name: oracle.sql.elapsed_time
            value_column: ELAPSED_TIME_SECONDS
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]
          - metric_name: oracle.sql.cpu_time
            value_column: CPU_TIME_SECONDS
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]
          - metric_name: oracle.sql.buffer_gets
            value_column: BUFFER_GETS
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]
          - metric_name: oracle.sql.disk_reads
            value_column: DISK_READS
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]
          - metric_name: oracle.sql.direct_writes
            value_column: DIRECT_WRITES
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]
          - metric_name: oracle.sql.physical_read_mb
            value_column: PHYSICAL_READ_MB
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]
          - metric_name: oracle.sql.physical_write_mb
            value_column: PHYSICAL_WRITE_MB
            data_type: gauge
            value_type: int
            attribute_columns: [SQL_ID, EXEC_ID, PLAN_HASH_VALUE, STATUS, USERNAME, MODULE]

      # 3) Recent SQL Statements with Correlation ID extraction
      - sql: |
          SELECT 
            sql.sql_id AS SQL_ID,
            sql.parsing_schema_name AS SCHEMA_NAME,
            'recent_sql' AS LOG_TYPE,
            sql.sql_text AS SQL_TEXT,
            TRUNC(sql.last_active_time) AS LAST_ACTIVE_TIME,
            sql.executions AS EXECUTION_COUNT,
            NVL(REGEXP_SUBSTR(sql.sql_text, 'CORRELATION_ID=([a-zA-Z0-9\-_]+)', 1, 1, NULL, 1), 'none') AS CORRELATION_ID,
            NVL(REGEXP_SUBSTR(sql.sql_text, 'USER_ACTION=([a-zA-Z0-9\-_]+)', 1, 1, NULL, 1), 'none') AS USER_ACTION
          FROM v$sql sql
          WHERE sql.last_active_time > SYSDATE - INTERVAL '2' MINUTE
            AND sql.parsing_schema_name IN ('TESTUSER', 'SYS') 
            AND sql.sql_text NOT LIKE '%v$sql%'
            AND sql.executions > 0
            AND ROWNUM <= 50
          ORDER BY sql.last_active_time DESC
        logs:
          - body_column: SQL_TEXT
            attribute_columns: [SQL_ID, SCHEMA_NAME, LOG_TYPE, EXECUTION_COUNT, CORRELATION_ID, USER_ACTION]
            
      # 4) Explain Plan Text  
      - sql: |
          SELECT 
            sql.sql_id AS SQL_ID,
            'explain_plan' AS LOG_TYPE,
            LISTAGG(
              pln.operation || ' ' || 
              CASE WHEN pln.options IS NOT NULL THEN '(' || pln.options || ') ' END ||
              CASE WHEN pln.object_name IS NOT NULL THEN 'ON ' || pln.object_name END,
              ' -> '
            ) WITHIN GROUP (ORDER BY pln.id) AS PLAN_TEXT
          FROM v$sql sql
          JOIN v$sql_plan pln ON sql.sql_id = pln.sql_id
          WHERE sql.last_active_time > SYSDATE - INTERVAL '2' MINUTE
            AND sql.parsing_schema_name IN ('TESTUSER', 'SYS')
            AND sql.sql_text NOT LIKE '%v$sql%'
            AND ROWNUM <= 20
          GROUP BY sql.sql_id
        logs:
          - body_column: PLAN_TEXT
            attribute_columns: [SQL_ID, LOG_TYPE]

processors:
  batch:
    timeout: 10s
    send_batch_size: 10

exporters:
  debug:
    verbosity: detailed
  prometheus:
    endpoint: "0.0.0.0:9464"
  otlphttp/observe:
    endpoint: "https://${OBSERVE_TENANT_ID}.${OBSERVE_STAGING_DOMAIN}/v2/otel"
    headers:
      authorization: "Bearer ${OBSERVE_BACKEND_BEARER_TOKEN}"
    compression: gzip

service:
  telemetry:
    logs:
      level: debug
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [debug, otlphttp/observe]
    metrics:
      receivers: [hostmetrics, sqlquery]
      processors: [batch]
      exporters: [prometheus, otlphttp/observe]
    logs:
      receivers: [sqlquery]
      processors: [batch]
      exporters: [debug, otlphttp/observe]